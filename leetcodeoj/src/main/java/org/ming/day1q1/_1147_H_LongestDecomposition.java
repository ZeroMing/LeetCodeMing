package org.ming.day1q1;

/**
 * @author liming53
 * @date 2023/4/12
 * @company 58房产 · 交易技术部
 * @since 1.0
 */
public class _1147_H_LongestDecomposition {
    public static void main(String[] args) {

    }

    public static int longestDecomposition(String text) {


        return -1;
    }


    /*
1147. 段式回文
提示
困难
120
相关企业
你会得到一个字符串 text 。你应该把它分成 k 个子字符串 (subtext1, subtext2，…， subtextk) ，要求满足:

subtexti 是 非空 字符串
所有子字符串的连接等于 text ( 即subtext1 + subtext2 + ... + subtextk == text )
对于所有 i 的有效值( 即 1 <= i <= k ) ，subtexti == subtextk - i + 1 均成立
返回k可能最大值。



示例 1：

输入：text = "ghiabcdefhelloadamhelloabcdefghi"
输出：7
解释：我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。
示例 2：

输入：text = "merchant"
输出：1
解释：我们可以把字符串拆分成 "(merchant)"。
示例 3：

输入：text = "antaprezatepzapreanta"
输出：11
解释：我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"。


提示：

1 <= text.length <= 1000
text 仅由小写英文字符组成
     */

}
